unit NNLayer;

interface

uses
  NNCommon;

type
  TNNLayer = class
  private
  protected
    FNeuralNetwork: TObject;
    FWeights: TNNDynArray;
    FBiases: TNNDynArray;
    FUseBiases: boolean;
    FOutput: TNNDynArray;
    FInput: PNNDynArray;
    FForwardPropagation: TNNProcess;
    FInitialize: TNNProcess;
    FBackwardPropagation: TNNProcess;
    procedure EmptyProcess;
    function GetBiases: PNNDynArray; inline;
    function GetWeights: PNNDynArray; inline;
    function GetOutput: PNNDynArray; inline;
  public
    constructor Create( const ANeuralNetwork: TObject ); virtual;
    property Input: PNNDynArray read FInput write FInput;
    property Output: PNNDynArray read GetOutput;
    property Weights: PNNDynArray read GetWeights;
    property Biases: PNNDynArray read GetBiases;
    property UseBiases: boolean read FUseBiases;
    procedure Build; virtual; abstract;
    property Initialize: TNNProcess read FInitialize;
    property ForwardPropagation: TNNProcess read FForwardPropagation;
    property BackwardPropagation: TNNProcess read FBackwardPropagation;
  end;

implementation

{ TNNLayer }

constructor TNNLayer.Create( const ANeuralNetwork: TObject );
begin
  FNeuralNetwork := ANeuralNetwork;
  FUseBiases := True;
end;

procedure TNNLayer.EmptyProcess;
begin

end;

function TNNLayer.GetBiases: PNNDynArray;
begin
  Result := @FBiases;
end;

function TNNLayer.GetOutput: PNNDynArray;
begin
  Result := @FOutput;
end;

function TNNLayer.GetWeights: PNNDynArray;
begin
  Result := @FWeights;
end;

end.
