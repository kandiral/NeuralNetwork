unit NNCommon;

interface

{$I NNConfig.inc}

type
  {$IFDEF NNFLOAT_SINGLE}
    NNFloat = Single;
  {$ELSE IFDEF NNFLOAT_DOUBLE}
    NNFloat = Double;
  {$ELSE}
    NNFloat = Extended;
  {$ENDIF}
  PNNFloat = ^NNFloat;

  TNNDynArray = array of NNFloat;
  PNNDynArray = ^TNNDynArray;

  TNNProcess = procedure of object;
  TNNForwardProcess = procedure( const AData: PNNFloat ) of object;
  TNNBackwardProcess = procedure( const AGradients: PNNFloat ) of object;

  TNNActivationMethod = ( amLinear );

  TNNPRNGenerator = ( prngMT19937 );

  TNNInitMethod = ( imNone, imZeros, imNormal, imUniform,
    imXavierGlorotNormal, imXavierGlorotUniform );
  TNNInitParams = packed record
    InitMethod: TNNInitMethod;
    Generator: TNNPRNGenerator;
    case Integer of
    0: ( _min, _max: NNFloat );
    1: ( _mu, _sigma: NNFloat );
  end;

  TNNLayerType = ( ltFullyConnected );

const
  NNFloatSize = SizeOf( NNFloat );

type
  TNNLosses = (
    nnlMSE, nnlMAE, nnlMAPE
  );

const
  TNNLosses_str : array[ TNNLosses ] of String = (
    'MSE', 'MAE', 'MAPE'
  );



implementation

end.
